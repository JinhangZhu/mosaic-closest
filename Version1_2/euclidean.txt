#H#######################################################################
# FILENAME :        mosaic.py             
#
# DESIGN REF :  https://stackoverflow.com/questions/34264710/what-is-the-point-of-floatinf-in-python
#               https://docs.python.org/2/library/multiprocessing.html#multiprocessing-programming
#
# DESCRIPTION :
#       Create a Mosaic of images that builds up an image.
#
# AUTHOR :          Jinhang <jinhang.d.zhu@gmail.com>
# VERSION :         1.0    
# START DATE :      17 Mar. 2019
#
#H#

import ctypes
import re
import os
import multiprocessing as mp
from multiprocessing.sharedctypes import RawArray
# from numpy import ctypeslib
import numpy as np 
import cv2
from scipy.spatial.distance import euclidean
from tqdm import tqdm

IMG_DIR = './images'
RATIO = 10

#
#   Resize the image to be in the shape of (height, width) without distortion
# #
def resize(source, height, width):
    shape_row = source.shape[0]
    shape_col = source.shape[1]
    shrink_ratio = min(shape_row/height, shape_col/width)
    resized = cv2.resize(source, (int(shape_col/shrink_ratio)+1, int(shape_row/shrink_ratio)+1), interpolation=cv2.INTER_CUBIC)
    result = resized[:height, :width, :]
    return result

#
#   Calculate the euclidean distance between two images
# #
def img_distance(source1, source2):
    if source1.shape != source2.shape:
        msg = "shapes are different {} {}".format(source1.shape, source2.shape)
        raise Exception(msg)
    array1 = source1.flatten()
    array2 = source2.flatten()
    dist = euclidean(array1, array2)
    return dist

#
#   Load images in a specific directory
# #
def load_images(height, width):
    img_dir = IMG_DIR
    filenames = os.listdir(img_dir)
    result = []
    print(len(filenames))
    for filename in tqdm(filenames):
        if not re.search('.jpg', filename, re.I):
            continue
        try:
            filepath = os.path.join(img_dir, filename)
            source_im = cv2.imread(filepath)
            # height_im = im.shape[0]
            # width_im = im.shape[1]
            source_im = resize(source_im, height, width)
            result.append(np.array(source_im))
        except Exception as e:
            msg = 'error with {} - {}'.format(filepath, str(e))
            print(msg)
    return np.array(result, dtype = np.uint8)

# 
#   Find the similarist image from the resource images by comparing euclidean distance
# #
def find_closest_image(q, shared_resource_images, resource_images_shape, shared_result, img_shape, set_height, set_width):
    shared_images_array = np.frombuffer(shared_resource_images, dtype=np.uint8)
    resource_images = shared_images_array.reshape(resource_images_shape)
    while True:
        [row, col, pad] = q.get()
        print('row: {}, col: {}'.format(row, col))
        min_dist = float("inf")     #   It acts as an unbounded upper value for comparison. This is useful for finding lowest values for something
        min_img = None
        for resource_image in resource_images:
            dist = img_distance(pad, resource_image)
            if dist < min_dist:
                min_dist = dist
                min_img = resource_image
        im_res = np.frombuffer(shared_result, dtype=np.uint8).reshape(img_shape)
        im_res[row:row+set_height, col:col+set_width, :] = min_img
        # 
        # Necessary method of JoinableQueue
        # To terminate the finished process
        # #
        q.task_done()

#   Return a fixed shape according to the original shape
def get_set_shape(shape):
    if shape[0] >= shape[1]:
        return [120, 90]
    else:
        return [90, 120]

#   Generate the mosaic with the resource image file and the output file indicated
def generate_mosaic(infile, outfile):
    img = cv2.imread(infile)
    set_height, set_width = get_set_shape(img.shape)
    img_shape = list(img.shape)

    #   Make corresponding shape of the full image accroding to the set shape of a single one
    img_shape[0] = int(img_shape[0]/set_height) * set_height * RATIO
    img_shape[1] = int(img_shape[1]/set_width) * set_width * RATIO
    img = cv2.resize(img, (img_shape[1], img_shape[0]), interpolation=cv2.INTER_CUBIC)
    # 
    # #
    # REF:  cv2.resize(src, dsize[, dst[, fx[, fy[, interpolation]]]]) ¡ú dst
    # dsize = Size(round(dst.cols), round(dst.rows))
    # #INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood
    #
    #   Print the shape of the output image
    print(img_shape)

    #   
    im_res = np.zeros(img_shape, np.uint8)
    #
    #   All resource image in the set shape to be used
    # #
    resource_images = load_images(set_height, set_width)
    #
    #   Get the shape of the images
    # #
    resource_images_shape = resource_images.shape
    #
    #   Return a ctypes array allocated from shared memory
    #   The ctypes array is of the same size of what needs to be shared across multiple processes
    # #
    shared_resource_images = RawArray(ctypes.c_ubyte, len(resource_images.flatten()))
    # 
    # np.frombuffer:    Intepret shared_resource_images as a 1-dimensional array
    # np.coyto:         Copy the values from the array: shared_resource_images to another array: resource_images
    # #
    np.copyto(np.frombuffer(shared_resource_images, dtype=np.uint8).reshape(resource_images_shape), resource_images)
    # 
    # Reruen a ctypes array allocated from shared memory
    # The ctypes array is in the shape of the flattened output image "pool"
    # #  
    shared_result = RawArray(ctypes.c_ubyte, len(im_res.flatten()))

    # 
    # Create a Queue subclass, a queue which additionally has task_done() and join() methods.
    # #
    join_queue = mp.JoinableQueue()
    for i in range(5):
        p = mp.Process(target=find_closest_image, # The callable object to be invoked
            name='Process: {}'.format(i),
            args=(join_queue, shared_resource_images, resource_images_shape, shared_result, img_shape, set_height, set_width),
            daemon=True) #  Make daemon process finish execution
        p.start()
        print("started process")
    
    #
    #   Generate the pads through multiple processes
    # #
    for row in range(0, img_shape[0], set_height):
        for col in range(0, img_shape[1], set_width):
            pad = img[row:row+set_height, col:col+set_width, :]
            #
            #   Put the value in the queue: Which firstly finishes calculation firstly processes the value
            # #
            join_queue.put([row, col, pad])

    join_queue.join()
    # 
    # Save the output image file
    # Multiple processes all modify the file in order
    # #
    cv2.imwrite(outfile, np.frombuffer(shared_result, dtype=np.uint8).reshape(img_shape))

if __name__ == "__main__":
    generate_mosaic("yo.jpg", "yoyo.jpg")